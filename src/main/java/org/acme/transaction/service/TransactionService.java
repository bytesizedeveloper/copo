package org.acme.transaction.service;

import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import lombok.extern.slf4j.Slf4j;
import org.acme.common.exception.CryptographicException;
import org.acme.common.exception.InsufficientBalanceException;
import org.acme.common.utility.TimestampUtility;
import org.acme.transaction.model.TransactionModel;
import org.acme.transaction.model.UtxoModel;
import org.acme.transaction.model.enumeration.TransactionType;
import org.acme.transaction.repository.TransactionRepository;
import org.acme.transaction.repository.UtxoRepository;
import org.acme.wallet.service.WalletService;

import java.math.BigDecimal;
import java.security.KeyStoreException;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;

/**
 * A service responsible for generating, validating, and finalizing all types of transactions
 * (transfers and block rewards) within the cryptocurrency system.
 * <p>
 * This service implements the core UTXO (Unspent Transaction Output) accounting logic, including
 * fee calculation, input selection, output generation, and cryptographic signing.
 */
@Slf4j
@ApplicationScoped
public class TransactionService {

    private final WalletService walletService;

    private final TransactionRepository transactionRepository;

    private final UtxoRepository utxoRepository;

    /**
     * Constructs the TransactionService, injecting necessary dependencies using constructor injection
     * for dependency finality.
     *
     * @param walletService The service responsible for cryptographic signing of transactions.
     * @param transactionRepository The repository for managing the state of transactions.
     * @param utxoRepository The repository for managing the state of Unspent Transaction Outputs (UTXOs).
     */
    @Inject
    public TransactionService(WalletService walletService, TransactionRepository transactionRepository, UtxoRepository utxoRepository) {
        this.walletService = walletService;
        this.transactionRepository = transactionRepository;
        this.utxoRepository = utxoRepository;
    }

    /**
     * Creates a standard fund transfer transaction between two parties.
     * <p>
     * This method automatically sets the transaction type to {@code TRANSFER} and delegates
     * to the core creation logic.
     *
     * @param transfer The partially built {@link TransactionModel} containing sender, recipient, and amount.
     * @return The fully initialized, signed, and updated {@link TransactionModel}.
     */
    public TransactionModel createTransfer(TransactionModel transfer) {
        transfer.setType(TransactionType.TRANSFER);

        return create(transfer);
    }

    /**
     * Creates a block reward transaction, generated by the mining process.
     * <p>
     * Reward transactions have no inputs and zero fees; they simply generate new currency.
     *
     * @param address The recipient's (miner's) wallet address.
     * @param amount The amount of the reward.
     * @return The fully initialized, signed, and updated {@link TransactionModel}.
     */
    public TransactionModel createReward(String address, BigDecimal amount) {
        TransactionModel reward = TransactionModel.builder()
                .senderAddress(address)
                .recipientAddress(address)
                .amount(amount)
                .type(TransactionType.REWARD)
                .build();

        return create(reward);
    }

    /**
     * Core method for processing and finalizing a transaction model.
     * <p>
     * This method handles fee calculation, input determination (for transfers), output generation,
     * transaction initialization, signing, and updates the transaction and UTXO repository state.
     *
     * @param transaction The partially initialized transaction model.
     * @return The fully signed {@link TransactionModel}.
     * @throws CryptographicException For errors during signing (e.g., failed key access).
     * @throws InsufficientBalanceException If the sender has insufficient balance.
     * @throws IllegalStateException For critical infrastructure failures like {@link KeyStoreException}.
     */
    private TransactionModel create(TransactionModel transaction) {
        OffsetDateTime now = TimestampUtility.getOffsetDateTimeNow();

        // 1. Initial setup
        BigDecimal fee = BigDecimal.ZERO;
        List<UtxoModel> inputs = new ArrayList<>();
        List<UtxoModel> outputs;

        try {
            if (transaction.isReward()) {
                outputs = generateOutputForReward(transaction, now);

            } else {
                fee = calculateTransactionFee();
                transaction.setFee(fee);
                log.debug("{} Transaction fee calculated: {}", transaction, fee);

                inputs = determineInputs(transaction);
                outputs = generateOutputsForTransfer(transaction, inputs, now);
            }

            transaction.setFee(fee);
            transaction.setInputs(inputs);
            transaction.setOutputs(outputs);

            // 2. Finalise and sign
            TransactionModel initialised = initialise(transaction, now);
            log.debug("{} Transaction initialised.", initialised);

            String signature = walletService.sign(initialised.getSenderAddress(), initialised.getHashId());
            initialised.setSignature(signature);
            log.debug("{} Transaction signed.", initialised);

            // 3. Update UTXO state (must happen after successful signing and commitment)
            if (!transaction.isReward() && !inputs.isEmpty()) {

                utxoRepository.updateUnspentUtxoToSpent(inputs.stream().map(UtxoModel::getId).toList());

                initialised.getInputs().forEach(input -> input.setSpent(true));
                log.debug("{} Transaction inputs marked as spent.", initialised);
            }

            // 4. Persist new transaction and outputs
            transactionRepository.insert(initialised);
            utxoRepository.batchInsert(outputs);

            return initialised;
        } catch (InsufficientBalanceException e) {
            log.error("{} Transaction failed - sender has insufficient balance: {}\n{}", transaction, transaction.getSenderAddress(), e.getMessage());
            throw e;

        } catch (KeyStoreException e) {
            log.error("{} Transaction failed - keystore failure: {}", transaction, e.getMessage());
            throw new IllegalStateException("Keystore failure - cannot access private key for signing.", e);

        } catch (CryptographicException e) {
            log.error("{} Transaction failed - cryptography exception: {}", transaction, e.getMessage());
            throw e;
        }
    }

    /**
     * Determines and selects the necessary {@link UtxoModel}s (inputs) for a transfer transaction.
     * <p>
     * Inputs are selected until the cumulative available amount meets or exceeds the total
     * required amount (transaction amount + fee). This prioritises older inputs.
     *
     * @param transaction The transaction containing the sender address and required amount.
     * @return A list of selected {@link UtxoModel}s to be consumed as inputs.
     * @throws InsufficientBalanceException If the sender does not have enough unspent funds.
     */
    private List<UtxoModel> determineInputs(TransactionModel transaction) throws InsufficientBalanceException {
        // Retrieve all available unspent UTXOs for the sender
        List<UtxoModel> unspentUtxos = utxoRepository.retrieveUnspentUtxosByRecipientAddress(transaction.getSenderAddress());

        BigDecimal totalRequired = transaction.getTotalRequired();

        BigDecimal available = BigDecimal.ZERO;
        List<UtxoModel> requiredForInput = new ArrayList<>();

        // Loop to accumulate inputs until available balance exceeds required
        for (UtxoModel unspentUtxo : unspentUtxos) {
            if (available.compareTo(totalRequired) >= 0) {
                break;
            }

            requiredForInput.add(unspentUtxo);
            available = available.add(unspentUtxo.getAmount());
        }

        // Final check after accumulating inputs
        if (available.compareTo(totalRequired) < 0) {
            String errorMessage = "Sender has insufficient balance. Required: " + totalRequired
                    + " (Amount: " + transaction.getAmount()
                    + " + Fee: " + transaction.getFee()
                    + ") Available: " + available;
            log.error("{} {}", transaction, errorMessage);
            throw new InsufficientBalanceException(errorMessage);
        }

        log.debug("{} Transaction inputs determined: {}", transaction, requiredForInput);
        return requiredForInput;
    }

    /**
     * Generates the transaction outputs for a standard transfer.
     * <p>
     * Always generates one output for the recipient. If there is a leftover amount after
     * subtracting the total required (amount + fee) from the inputs, a second output
     * (change) is generated and sent back to the sender's address.
     *
     * @param transfer The finalized transaction model.
     * @param now The current timestamp for output creation.
     * @return A list of new {@link UtxoModel}s (outputs).
     */
    private List<UtxoModel> generateOutputsForTransfer(TransactionModel transfer, List<UtxoModel> inputs, OffsetDateTime now) {
        BigDecimal availableFunds = inputs.stream()
                .map(UtxoModel::getAmount).reduce(BigDecimal.ZERO, BigDecimal::add);

        BigDecimal totalRequired = transfer.getTotalRequired();
        BigDecimal change = availableFunds.subtract(totalRequired);

        List<UtxoModel> outputs = new ArrayList<>();

        // Output for the recipient (index 00)
        UtxoModel utxoForRecipient = UtxoModel.builder()
                .outputIndex("00")
                .recipientAddress(transfer.getRecipientAddress())
                .amount(transfer.getAmount())
                .createdAt(now)
                .isSpent(false)
                .build();
        outputs.add(utxoForRecipient);

        // Output for the change back to the sender (index 01, only if positive)
        if (change.compareTo(BigDecimal.ZERO) > 0) {
            UtxoModel changeForSender = UtxoModel.builder()
                    .outputIndex("01")
                    .recipientAddress(transfer.getSenderAddress())
                    .amount(change)
                    .createdAt(now)
                    .isSpent(false)
                    .build();
            outputs.add(changeForSender);
        }

        log.debug("{} Transaction outputs generated: {}", transfer, outputs);
        return outputs;
    }

    /**
     * Generates the single output for a block reward transaction.
     *
     * @param reward The reward transaction model.
     * @param now The current timestamp for output creation.
     * @return A list containing the single reward {@link UtxoModel}.
     */
    private List<UtxoModel> generateOutputForReward(TransactionModel reward, OffsetDateTime now) {
        UtxoModel output = UtxoModel.builder()
                .outputIndex("00")
                .recipientAddress(reward.getRecipientAddress())
                .amount(reward.getAmount())
                .createdAt(now)
                .isSpent(false)
                .build();

        log.debug("{} Transaction output generated: {}", reward, output);
        return List.of(output);
    }

    /**
     * Calculates the transaction fee.
     * <p>
     * Currently returns {@code BigDecimal.ZERO} as a placeholder.
     *
     * @return The calculated fee amount.
     */
    private BigDecimal calculateTransactionFee() {
        return BigDecimal.ZERO; // Placeholder for now
    }

    /**
     * Finalizes the transaction by setting the creation timestamp, calculating the transaction hash ID,
     * and assigning the transaction hash ID to all generated outputs.
     * <p>
     * This prepares the transaction for the signing process.
     *
     * @param transaction The transaction model to initialize.
     * @param now The creation timestamp.
     * @return The initialized {@link TransactionModel} ready for signing.
     */
    private TransactionModel initialise(TransactionModel transaction, OffsetDateTime now) {
        TransactionModel initialised = transaction.toBuilder()
                .createdAt(now)
                .build();

        initialised.calculateHashId();

        initialised.getOutputs().forEach(output -> output.setTransactionHashId(initialised.getHashId()));

        return initialised;
    }
}

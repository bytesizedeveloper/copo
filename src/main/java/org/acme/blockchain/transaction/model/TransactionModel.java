package org.acme.blockchain.transaction.model;

import lombok.Builder;
import lombok.Data;
import lombok.EqualsAndHashCode;
import org.acme.blockchain.common.model.AddressModel;
import org.acme.blockchain.common.model.CoinModel;
import org.acme.blockchain.common.utility.HashUtility;
import org.acme.blockchain.transaction.model.enumeration.TransactionStatus;
import org.acme.blockchain.transaction.model.enumeration.TransactionType;

import java.math.BigDecimal;
import java.time.Instant;
import java.time.OffsetDateTime;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.List;

/**
 * The core domain model representing a single transaction in the blockchain.
 * <p>
 * A transaction defines a transfer of address (or creation of address, in the case of a reward)
 * from a set of inputs (UTXOs) to a set of outputs (new UTXOs). It is uniquely identified by
 * its cryptographic hash and secured by a digital signature.
 */
@Data
@Builder(toBuilder = true)
public class TransactionModel {

    /**
     * Primary key of the transaction record in the local database. Not part of the blockchain state.
     */
    private long id;

    /**
     * The unique cryptographic hash ID of the transaction, calculated from its contents.
     * This is the data that is digitally signed.
     */
    private String hashId;

    /**
     * The address initiating the transaction (the spender).
     */
    private AddressModel senderAddress;

    /**
     * The address receiving the main transaction amount.
     */
    private AddressModel recipientAddress;

    byte[] senderPublicKeyEncoded;

    /**
     * The principal monetary amount being transferred to the recipient.
     * Excluded from default {@code equals}/{@code hashCode} to use the custom precision comparison.
     */
    private CoinModel amount;

    /**
     * The fee paid to the miner/network for including this transaction.
     * Excluded from default {@code equals}/{@code hashCode} to use the custom precision comparison.
     */
    private CoinModel fee;

    /**
     * The type of transaction (e.g., TRANSFER, REWARD).
     */
    private TransactionType type;

    /**
     * The list of Unspent Transaction Outputs (UTXOs) being consumed by this transaction.
     * This proves the sender is authorized to spend the funds.
     */
    private List<UtxoModel> inputs;

    /**
     * The list of new Unspent Transaction Outputs (UTXOs) being created by this transaction.
     * This defines where the funds (and change) are going.
     */
    private List<UtxoModel> outputs;

    /**
     * The timestamp when the transaction was created.
     * Excluded from default {@code equals}/{@code hashCode} to use the custom truncated comparison.
     */
    @EqualsAndHashCode.Exclude
    private OffsetDateTime createdAt;

    /**
     * The digital signature created by the sender's private key over the {@code hashId}.
     */
    private String signature;

    private TransactionStatus status;

    /**
     * Calculates the unique cryptographic hash ID for the transaction and assigns it to the {@code hashId} field.
     * <p>
     * The hash is calculated over the immutable data generated by {@code getData()}, ensuring
     * any change to inputs, outputs, amounts, fees, or addresses results in a new hash.
     */
    public void calculateHashId() {
        this.hashId = HashUtility.calculateSHA256d(getData());
    }

    /**
     * Concatenates the core immutable fields of the transaction into a single string for hashing.
     * <p>
     * Note: This method must include all fields that define the transaction's identity and address
     * but *must not* include the {@code hashId} or {@code signature} itself.
     *
     * @return The concatenated string of transaction data used for hashing.
     */
    public String getData() {
        return this.senderAddress.value() +
                this.recipientAddress.value() +
                Arrays.toString(this.senderPublicKeyEncoded) +
                this.amount.value() +
                this.fee +
                this.type +
                getInputIds() +
                this.createdAt;
    }

    /**
     * Checks if the transaction is of type {@code REWARD}.
     *
     * @return {@code true} if the transaction is a reward, {@code false} otherwise.
     */
    public boolean isReward() {
        return TransactionType.REWARD.equals(this.type);
    }

    /**
     * Calculates the total funds required to process the transaction.
     * <p>
     * This is the sum of the main transfer {@code amount} and the transaction {@code fee}.
     *
     * @return The total required amount (Amount + Fee).
     */
    public CoinModel getTotalRequired() {
        return this.amount.add(this.fee);
    }

    public CoinModel getTotalValueOfInputs() {
        return this.inputs.stream().map(UtxoModel::getAmount).reduce(new CoinModel(BigDecimal.ZERO), CoinModel::add);
    }

    public boolean isTerminal() {
        return TransactionStatus.INVALIDATED.equals(this.status) ||
                TransactionStatus.REJECTED.equals(this.status) ||
                TransactionStatus.MINED.equals(this.status) ||
                TransactionStatus.FAILED.equals(this.status);
    }

    /**
     * Provides a short, human-readable summary of the transaction for logging purposes.
     *
     * @return A formatted string showing the truncated hash, sender, recipient, and amount.
     */
    @Override
    public String toString() {
        String format = """
                %s | %s -> %s : %s #""";
        return format.formatted(
                this.hashId != null ? this.hashId.substring(0, 16) : "[NOT CALCULATED]",
                this.senderAddress,
                this.recipientAddress,
                this.amount
        );
    }

    /**
     * Concatenates the unique UTXO IDs of all inputs to create a single string for inclusion in the transaction hash data.
     *
     * @return A concatenated string of all input UTXO IDs.
     */
    private String getInputIds() {
        return this.inputs.stream()
                .map(UtxoModel::getUtxoId).reduce("", String::concat);
    }

    /**
     * Custom comparison method for the {@code createdAt} field used by {@code equals} and {@code hashCode}.
     * Truncates the timestamp to millisecond precision to ensure two transactions created close
     * in time (but not the exact nanosecond) are considered equal if they are logically the same instance.
     *
     * @return The truncated Instant address, or null.
     */
    @EqualsAndHashCode.Include
    private Instant getCreatedAtForEquals() {
        return this.createdAt != null ? this.createdAt.truncatedTo(ChronoUnit.MILLIS).toInstant() : null;
    }
}

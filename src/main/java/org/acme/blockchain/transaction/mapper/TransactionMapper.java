package org.acme.blockchain.transaction.mapper;

import jooq.tables.records.TransactionRecord;
import org.acme.blockchain.common.mapper.AddressMapper;
import org.acme.blockchain.common.mapper.CoinMapper;
import org.acme.blockchain.transaction.api.contract.TransactionRequest;
import org.acme.blockchain.transaction.api.contract.TransactionResponse;
import org.acme.blockchain.transaction.model.TransactionModel;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.factory.Mappers;

/**
 * MapStruct interface for defining mappings between the Transaction domain model ({@link TransactionModel}),
 * its API request/response DTOs, and its database representation ({@link TransactionRecord}).
 * <p>
 * This mapper delegates the conversion of input and output lists to the {@code UtxoMapper}.
 */
@Mapper(uses = {AddressMapper.class, CoinMapper.class, UtxoMapper.class})
public interface TransactionMapper {

    /**
     * Singleton instance of the mapper, initialized by MapStruct's Mappers factory.
     */
    TransactionMapper INSTANCE = Mappers.getMapper(TransactionMapper.class);

    /**
     * Converts a simplified {@link TransactionRequest} DTO into a {@link TransactionModel} domain object.
     * <p>
     * **Critical Mapping Rule:** Most fields are ignored because they are generated or determined
     * by the business logic in the {@code TransactionService} *after* the request is received.
     * Only the fundamental transfer details (sender, recipient, amount) are mapped.
     * </p>
     *
     * @param transactionRequest The request DTO received from the client.
     * @return The partially initialized transaction domain model.
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "hashId", ignore = true)
    @Mapping(target = "fee", ignore = true)
    @Mapping(target = "type", ignore = true)
    @Mapping(target = "inputs", ignore = true)
    @Mapping(target = "outputs", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    @Mapping(target = "signature", ignore = true)
    @Mapping(target = "status", ignore = true)
    TransactionModel requestToModel(TransactionRequest transactionRequest);

    /**
     * Converts a fully processed {@link TransactionModel} domain object into an API-friendly
     * {@link TransactionResponse} DTO.
     * <p>
     * This mapping includes the generated {@code hashId}, {@code signature}, {@code fee},
     * and the list of new {@code outputs}.
     * </p>
     *
     * @param transactionModel The finalized transaction domain model.
     * @return The corresponding response DTO.
     */
    TransactionResponse modelToResponse(TransactionModel transactionModel);

    /**
     * Converts a {@link TransactionModel} domain object into a database-specific {@link TransactionRecord}.
     * <p>
     * Note: The primary key {@code id} is ignored as it is generated by the database.
     * The input and output lists are implicitly handled by the persistence layer
     * and are mapped in separate repository calls.
     * </p>
     *
     * @param transactionModel The domain model to convert.
     * @return The corresponding jOOQ record object ready for insertion.
     */
    @Mapping(target = "id", ignore = true)
    TransactionRecord modelToRecord(TransactionModel transactionModel);

    /**
     * Converts a database-specific {@link TransactionRecord} into a {@link TransactionModel} domain object.
     * <p>
     * Note: The collections {@code inputs} and {@code outputs} are ignored here because they
     * require separate queries in the repository layer to be fully loaded,
     * preventing lazy-loading issues and keeping the core transaction record mapping simple.
     * </p>
     *
     * @param transactionRecord The database record to convert.
     * @return The corresponding transaction domain model.
     */
    @Mapping(target = "inputs", ignore = true)
    @Mapping(target = "outputs", ignore = true)
    @Mapping(target = "status", ignore = true)
    TransactionModel recordToModel(TransactionRecord transactionRecord);
}

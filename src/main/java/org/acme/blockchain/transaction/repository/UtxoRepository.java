package org.acme.blockchain.transaction.repository;

import org.acme.blockchain.transaction.mapper.UtxoMapper;
import org.acme.blockchain.transaction.model.UtxoModel;
import io.agroal.api.AgroalDataSource;
import jakarta.enterprise.context.ApplicationScoped;
import jakarta.inject.Inject;
import jooq.tables.Utxo;
import jooq.tables.records.UtxoRecord;
import org.jooq.DSLContext;
import org.jooq.SQLDialect;
import org.jooq.impl.DSL;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Repository class responsible for all database interactions related to the Unspent Transaction Output (UTXO) model.
 * <p>
 * This class uses jOOQ's {@link DSLContext} to perform strongly-typed CRUD operations,
 * primarily focusing on managing the spent status and retrieval of UTXOs by address.
 */
@ApplicationScoped
public class UtxoRepository {

    /**
     * The jOOQ context used to build and execute SQL queries.
     */
    private final DSLContext dslContext;

    /**
     * Constructs the UtxoRepository, initializing the jOOQ DSLContext.
     *
     * @param agroalDataSource The Agroal data source provided by the application environment for database connection
     * pooling.
     */
    @Inject
    public UtxoRepository(AgroalDataSource agroalDataSource) {
        this.dslContext = DSL.using(agroalDataSource, SQLDialect.POSTGRES);
    }

    /**
     * Executes a batch insertion of multiple {@link UtxoModel} records into the database.
     * <p>
     * This method is significantly more efficient than inserting records one by one,
     * as it leverages the underlying database driver's support for batch operations.
     *
     * @param utxos The {@link List} of {@link UtxoModel} objects to be inserted.
     * These typically represent the outputs generated by a newly finalized transaction.
     * @see UtxoMapper#modelToRecord(UtxoModel)
     */
    public void batchInsert(List<UtxoModel> utxos) {
        List<UtxoRecord> toInsert = utxos.stream().map(UtxoMapper.INSTANCE::modelToRecord).collect(Collectors.toList());

        dslContext.insertInto(Utxo.UTXO)
                .set(toInsert)
                .execute();
    }

    public boolean isSpent(UtxoModel utxo) {
        return dslContext
                .fetchExists(dslContext
                        .selectOne()
                        .from(Utxo.UTXO)
                        .where(Utxo.UTXO.TRANSACTION_HASH_ID.eq(utxo.getTransactionHashId()))
                        .and(Utxo.UTXO.OUTPUT_INDEX.eq(utxo.getOutputIndex()))
                        .and(Utxo.UTXO.IS_SPENT.isTrue()));
    }

    /**
     * Retrieves all unspent UTXOs associated with a specific recipient address.
     * <p>
     * UTXOs are ordered by creation time in ascending order (oldest first) to facilitate input selection
     * in the {@code TransactionService}.
     *
     * @param recipientAddress The address to search for.
     * @return A {@link List} of unspent {@link UtxoModel}s belonging to the address.
     */
    public List<UtxoModel> retrieveUnspentUtxosByRecipientAddress(String recipientAddress) {
        List<UtxoRecord> utxoRecords = dslContext
                .selectFrom(Utxo.UTXO)
                .where(Utxo.UTXO.RECIPIENT_ADDRESS.eq(recipientAddress))
                .and(Utxo.UTXO.IS_SPENT.isFalse())
                .orderBy(Utxo.UTXO.CREATED_AT.asc())
                .fetch();

        return utxoRecords.stream().map(UtxoMapper.INSTANCE::recordToModel).toList();
    }

    /**
     * Updates the status of a batch of UTXOs, marking them as spent.
     * <p>
     * This method is called after a transaction has been successfully created and signed, indicating
     * that the corresponding inputs are now consumed.
     *
     * @param utxoIds A {@link List} of primary keys (IDs) of the UTXOs to be marked as spent.
     */
    public void updateUnspentUtxoToSpent(List<Long> utxoIds) {
        dslContext
                .update(Utxo.UTXO)
                .set(Utxo.UTXO.IS_SPENT, true)
                .where(Utxo.UTXO.ID.in(utxoIds))
                .execute();
    }
}
